<h3 align="center"> Universidad Peruana de Ciencias Aplicadas </h3>

<h3 align="center"> Ingeniería de Software </h3>
<h3 align="center"> Ciclo 2024 - 2 </h3>

<br>

<div align="center">
  <img width=140 src="https://seeklogo.com/images/U/universidad-peruana-de-ciencias-aplicadas-upc-logo-B98C3A365C-seeklogo.com.png"/>
</div>

<br>

<h1 align="center"> TB1 Report </h1>

<h3 align="center"> Desarrollo de Soluciones IoT - SW53 </h3>

<h3 align="center"> Docente:  </h3>

<h3> Startup: HidroBots </h3>

<h3> Product: </h3>

<h3> Team Members: </h3>

<div align="center">

| Member                              |    Code    |
| :---------------------------------- | :--------: |
| Ampudia Flores, José Carlos Isaac   | u202112936 |
| Defilippi Santillán, Diego          | U202120448 |
| Horna Silva, Fabio Ernesto          | u202020229 |
| Lopez Huarcaya, Leonardo Paul       | u202124304 |
| Paucar De La Cruz, Tatiana Medalith | u20211f955 |

</div>

<h3 align="center">Septiembre, 2024</h3>

<br><br>

# Registro de Versiones del Informe

<br><br>

# Project Report Collaboration Insights

<br><br>

# Contenido

## Tabla de Contenidos

### [Registro de versiones del informe](#registro-de-versiones-del-informe)

### [Project Report Collaboration Insights](#project-report-collaboration-insights)

### [Contenido](#contenido)

### [Student Outcome](#student-outcome-1)

### [Capítulo I: Introducción](#capítulo-i-introducción-1)

- [1.1. Startup Profile](#11-startup-profile)
  - [1.1.1. Descripción de la Startup](#111-descripción-de-la-startup)
  - [1.1.2. Perfiles de integrantes del equipo](#112-perfiles-de-integrantes-del-equipo)
- [1.2. Solution Profile](#12-solution-profile)
  - [1.2.1 Antecedentes y problemática](#121-antecedentes-y-problemática)
  - [1.2.2 Lean UX Process](#122-lean-ux-process)
    - [1.2.2.1. Lean UX Problem Statements](#1221-lean-ux-problem-statements)
    - [1.2.2.2. Lean UX Assumptions](#1222-lean-ux-assumptions)
    - [1.2.2.3. Lean UX Hypothesis Statements](#1223-lean-ux-hyphotesis-statements)
    - [1.2.2.4. Lean UX Canvas](#1224-lean-ux-canvas)
- [1.3. Segmentos objetivo](#13-segmentos-objetivo)

### [Capítulo II: Requirements Elicitation & Analysis](#capítulo-ii-requirements-elicitation--analysis-1)

- [2.1. Competidores](#21-competidores)
  - [2.1.1. Análisis competitivo](#211-análisis-competitivo)
  - [2.1.2. Estrategias y tácticas frente a competidores](#212-estrategias-y-tácticas-frente-a-competidores)
- [2.2. Entrevistas](#22-entrevistas)
  - [2.2.1. Diseño de entrevistas](#221-diseño-de-entrevistas)
  - [2.2.2. Registro de entrevistas](#222-registro-de-entrevistas)
  - [2.2.3. Análisis de entrevistas](#223-análisis-de-entrevistas)
- [2.3. Needfinding](#23-needfinding)
  - [2.3.1. User Personas](#231-user-personas)
  - [2.3.2. User Task Matrix](#232-user-task-matrix)
  - [2.3.3. User Journey Mapping](#233-user-journey-mapping)
  - [2.3.4. Empathy Mapping](#234-empathy-mapping)
  - [2.3.5. As-is Scenario Mapping](#235-as-is-scenario-mapping)
- [2.4. Ubiquitous Language](#24-ubiquitous-language)

### [Capítulo III: Requirements Specification](#capítulo-iii-requirements-specification-1)

- [3.1. To-Be Scenario Mapping](#31-to-be-scenario-mapping)
- [3.2. User Stories](#32-user-stories)
- [3.3. Impact mapping](#33-impact-mapping)
- [3.4. Product Backlog](#34-product-backlog)

### [Capítulo IV: Solutions Software Design](#capítulo-iv-solution-software-design)

- [4.1. Strategic-Level Domain-Driven Design](#41-strategic-level-domain-driven-design)
  - [4.1.1. Event Storming](#411-event-storming)
    - [4.1.1.1. Candidate Context Discovery](#4111-candidate-context-discovery)
    - [4.1.1.2. Domain Message Flows Modeling](#4112-domain-message-flows-modeling)
    - [4.1.1.3. Bounded COntext Canvases](#4113-bounded-context-canvases)
  - [4.1.2. Context Mapping](#412-context-mapping)
  - [4.1.3. Software Architecture](#413-software-architecture)
    - [4.1.3.1. Software Architecture System Landscape Diagram](#4131-software-architecture-system-landscape-diagram)
    - [4.1.3.2. Software Architecture Context Level Diagrams](#4132-software-architecture-context-level-diagrams)
    - [4.1.3.3. Software Architecture Container Level Diagrams](#4133-software-architecture-container-level-diagrams)
    - [4.1.3.4. Software Architecture Deployment Diagrams](#4134-software-architecture-deployment-diagrams)
- [4.2. Tactical-Level Domain-Driven Design](#42-tactical-level-domain-driven-design)
  - [4.2.X. Bounded Context: <Bounded Context name>](#42x-bounded-context)
    - [4.2.X.1. Domain Layer](#42x1-domain-layer)
    - [4.2.X.2. Interface Layer](#42x2-interface-context)
    - [4.2.X.3. Application Layer](#42x3-application-context)
    - [4.2.X.4. Infrastructure Layer](#42x4-infrastructure-context)
    - [4.2.X.5. Bounded Context Software Architecture Component Level Diagrams](#42x5-bounded-context-software-architecture-component-level-diagrams)
    - [4.2.X.6. Bounded Context Software Architecture Code Level Diagrams](#42x6-bounded-context-software-architecture-code-level-diagrams)
      - [4.2.X.6.1. Bounded Context Domain Layer Class Diagrams](#42x61-bounded-context-domain-layer-class-diagrams)
      - [4.2.X.6.2. Bounded Context Database Design Diagram](#42x62-bounded-context-database-design-diagram)

### [Capítulo V: Solution UI/UX Design](#capítulo-v-solutions-uiux-design)

- [5.1. Style Guidelines](#51-style-guidelines)
  - [5.1.1. General Style Guidelines](#511-general-style-guidelines)
  - [5.1.2. Web Style Guidelines](#512-web-style-guidelines)
- [5.2. Information Architecture](#52-information-architecture)
  - [5.2.1. Organization Systems](#521-organization-systems)
  - [5.2.2. Labeling Systems](#522-labeling-systems)
  - [5.2.3. SEO Tags and Meta Tags](#523-seo-tags-and-meta-tags)
  - [5.2.4. Searching Systems](#524-searching-systems)
  - [5.2.5. Navigation Systems](#525-navigation-systems)
- [5.3. Landing Page UI Design](#53-landing-page-ui-design)
  - [5.3.1. Landing Page Wireframe](#531-landing-page-wireframe)
  - [5.3.2. Landing Page Mock-up](#532-landing-page-mock-up)
- [5.4. Applications UX/UI Design](#54-web-applications-uxui-design)
  - [5.4.1. Applications Wireframes](#541-web-applications-wireframes)
  - [5.4.2. Applications Wireflow Diagrams](#542-web-applications-wireflow-diagrams)
  - [5.4.3. Applications Mock-ups](#543-web-applications-mock-ups)
  - [5.4.4. Applications User Flow Diagrams](#544-web-applications-user-flow-diagrams)
- [5.5. Aplications Prototyping](#55-applications-prototyping)

### [Capítulo VI: Product Implementation, Validation \& Deployment](#capítulo-vi-product-implementation-validation--deployment)

- [6.1. Software Configuration Management](#61-software-configuration-management)
  - [6.1.1. Software Development Environment Configuration](#611-software-development-environment-configuration)
  - [6.1.2. Source Code Management](#612-source-code-management)
  - [6.1.3. Source Code Style Guide \& Conventions](#613-source-code-style-guide--conventions)
  - [6.1.4. Software Deployment Configuration](#614-software-deployment-configuration)
- [6.2. Landing Page, Services \& Applications Implementation](#62-landing-page-services--applications-implementation)
  - [6.2.X. Sprint X](#62x-sprint-n)
    - [6.2.X.1. Sprint Planning 1](#62x1-sprint-planning-n)
    - [6.2.X.2. Sprint Backlog 1](#62x2-sprint-backlog-n)
    - [6.2.X.3. Development Evidence for Sprint Review](#62x3-development-evidence-for-sprint-review)
    - [6.2.X.4. Testing Suite Evidence for Sprint Review](#62x4-testing-suite-evidence-for-sprint-review)
    - [6.2.X.5. Execution Evidence for Sprint Review](#62x5-execution-evidence-for-sprint-review)
    - [6.2.X.6. Services Documentation Evidence for Sprint Review](#62x6-services-documentation-evidence-for-sprint-review)
    - [6.2.X.7. Software Deployment Evidence for Sprint Review](#62x7-software-deployment-evidence-for-sprint-review)
    - [6.2.X.8. Team Collaboration Insights during Sprint](#62x8-team-collaboration-insights-during-sprint)
- [6.3. Validation Interviews](#63-validation-interviews)
  - [6.3.1. Diseño de Entrevistas](#631-diseño-de-entrevistas)
  - [6.3.2. Registro de Entrevistas](#632-registro-de-entrevistas)
  - [6.3.3. Evaluaciones según heurísticas](#633-evaluaciones-según-heurísticas)
- [6.4. Video About-the-Product](#64-video-about-the-product)

### [Conclusiones](#conclusiones-1)

- [Conclusiones y recomendaciones](#conclusiones-y-recomendaciones)
- [Video About-the-Team](#video-about-the-team)

### [Bibliografía](#bibliografía-1)

### [Anexos](#anexos-1)

<br><br>

# Student Outcome

<b>ABET – EAC - Student Outcome 5:</b> La capacidad de funcionar efectivamente en un equipo cuyos miembros juntos proporcionan liderazgo, crean un entorno de colaboración e inclusivo, establecen objetivos, planifican tareas y cumplen objetivos.

<br><br>

# Capítulo I: Introducción

## 1.1. StartUp Profile

### 1.1.1. Descripción de la StartUp

### 1.1.2. Perfiles de integrantes del equipo

## 1.2. Solution Profile

### 1.2.1. Antecedentes y problemática

### 1.2.2. Lean UX Process

#### 1.2.2.1. Lean UX Problem Statements

#### 1.2.2.2. Lean UX Assumptions

#### 1.2.2.3. Lean UX Hyphotesis Statements

#### 1.2.2.4. Lean UX Canvas

## 1.3. Segmentos objetivo

# Capítulo II: Requirements Elicitation & Analysis

## 2.1. Competidores

### 2.1.1. Análisis competitivo

### 2.1.2. Estrategias y tácticas frente a competidores

## 2.2. Entrevistas

### 2.2.1. Diseño de entrevistas

### 2.2.2. Registro de entrevistas

### 2.2.3. Análisis de entrevistas

## 2.3. Needfinding

### 2.3.1. User Personas

### 2.3.2. User Task Matrix

### 2.3.3. User Journey Mapping

### 2.3.4. Empathy Mapping

### 2.3.5. As-Is Scenario Mapping

## 2.4. Ubiquitous Language

# Capítulo III: Requirements Specification

## 3.1. To-Be Scenario Mapping

## 3.2. User Stories

## 3.3. Impact mapping

## 3.4. Product Backlog


<div align="justify">

# Capítulo IV: Solution Software Design

## 4.1. Strategic-Level Domain-Driven Design

En nuestro equipo, abordamos las decisiones estratégicas utilizando Domain-Driven Design (DDD) para asegurarnos de que comprendemos a fondo el dominio y sus complejidades. Aplicamos Event Storming como primera herramienta, lo que nos permitió identificar juntos los eventos clave dentro del sistema y visualizar cómo fluye la información y las interacciones en el negocio.

Después, utilizamos el Bounded Context Canvas para definir claramente los límites de cada contexto dentro del dominio. Esto nos ayudó a organizar las responsabilidades y asegurar que cada parte del sistema estuviera alineada tanto con la visión de negocio como con las capacidades técnicas. Gracias a estas herramientas, pudimos tomar decisiones estratégicas más informadas y coherentes, asegurando que el desarrollo estuviera bien fundamentado en las necesidades reales del negocio.

### 4.1.1. Event Storming

Event Storming es una herramienta que nos permite descubrir el comportamiento de un negocio, recopilando eventos importantes del negocio, los actores principales, servicios de terceros y otros. Para la implementación de esta sección se realizaron entrevistas correspondientes a los segmentos objetivos, de esta manera pudimos identificar los eventos principales y desarrollar un entendimiento común.

Aquí mostramos los pasos respectivos para la elaboración correcta del Event Storming realizada en la herramienta de Miro.

##### **Step 1: Unstructured Exploration**

En esta sección se realizó una lluvia de ideas de los eventos del dominio
relacionados con el dominio empresarial que se está explorando. Nos permitió identificar los eventos clave y las interacciones entre ellos.

![Step_1_Unstructured_Exploration](assets/Event_Storming_Steps/1%20paso/paso_1_unstructured_exploration.jpg)


##### **Step 2: Timelines**

En esta sección, los eventos identificados previamente, son agrupados en subgrupos lo cual tiene como lider al evento principal (es quien encapsula la funcionalidad principal del grupo). Estos eventos comienzan con el flujo que describe el escenario empresarial exitoso (Happy path) y también escenarios alternativos.

![Step_2_Timelines](assets/Event_Storming_Steps/2%20paso/paso_2_timelines.png)


##### **Step 3: Paint Points**

Durante esta fase, identificamos puntos problemáticos o (Pair Points) que son áreas donde los usuarios pueden obtener dificultades al momento de realizar una respectiva funcionalidad en la aplicación. Estos puntos son importantes para mejorar la experiencia de usuario e implementar una aplicación eficiente.

![Step_3_Paint_Points](assets/Event_Storming_Steps/3%20paso/paso_3_pair_points_1.jpg)
![Step_3_Paint_Points](assets/Event_Storming_Steps/3%20paso/paso_3_pair_points_2.jpg)

##### **Step 4: Pivotal Points**

En esta fase, nos enfocamos en identificar los puntos cruciales dentro del flujo del negocio, los cuales tienen un impacto significativo en la operatividad del sistema o el comportamiento del usuario. Estos puntos nos ayudan a priorizar qué áreas deben ser optimizadas o revisadas con mayor detalle, ya que pueden afectar el éxito de los procesos empresariales críticos.

![Step_4_Pivotal_Process](assets/Event_Storming_Steps/4%20paso/paso_4_pivotal_points_1.jpg)
![Step_4_Pivotal_Process](assets/Event_Storming_Steps/4%20paso/paso_4_pivotal_points_2.jpg)

##### **Step 5: Commands**

Los comandos representan acciones que los actores del sistema pueden ejecutar. Durante este paso, mapeamos qué acciones desencadenan los eventos clave dentro del sistema y qué actores son responsables de ejecutarlas. Esto nos ayuda a estructurar la lógica de negocio alrededor de acciones claras y específicas, facilitando la implementación de las reglas del negocio.

![Step_5_Commands](assets/Event_Storming_Steps/5%20paso/paso_5_commands_1.jpg)
![Step_5_Commands](assets/Event_Storming_Steps/5%20paso/paso_5_commands_2.png)
![Step_5_Commands](assets/Event_Storming_Steps/5%20paso/paso_5_commands_3.jpg)

##### **Step 6: Policies**

En este paso, se identifican las políticas, que son reglas de negocio o condiciones que deben cumplirse para que un comando pueda ser ejecutado o un evento pueda suceder. Las políticas son esenciales para definir las restricciones del sistema y asegurar que el flujo de eventos sea coherente con las reglas del negocio.

![Step_6_Policies](assets/Event_Storming_Steps/6%20paso/paso_6_policies_1.png)
![Step_6_Policies](assets/Event_Storming_Steps/6%20paso/paso_6_policies_2.png)

##### **Step 7: Read Models**

Los Read Models son vistas del estado del sistema, generalmente optimizadas para la consulta por parte de los usuarios o procesos. Durante este paso, definimos qué información necesita ser accesible en ciertos momentos y cómo debería ser presentada, asegurando que los actores puedan visualizar el estado del sistema de manera eficiente.

![Step_7_Read_Models](assets/Event_Storming_Steps/7%20paso/7_paso_read_models_1.png)
![Step_7_Read_Models](assets/Event_Storming_Steps/7%20paso/7_paso_read_models_2.png)

##### **Step 8: External Systems**

En esta fase, identificamos los sistemas externos que interactúan con nuestro dominio. Aquí mapeamos las conexiones con servicios de terceros o sistemas independientes que influyen en los eventos del negocio. Es crucial entender cómo estos sistemas externos afectan los flujos y asegurar que las integraciones sean correctas.

![Step_8_External_Systems](assets/Event_Storming_Steps/8%20paso/paso_8_external_systems_1.png)
![Step_8_External_Systems](assets/Event_Storming_Steps/8%20paso/paso_8_external_systems_2.png)
![Step_8_External_Systems](assets/Event_Storming_Steps/8%20paso/paso_8_external_systems_3.png)

##### **Step 9: Aggregates**

En este último paso, agrupamos los eventos y comandos que pertenecen a un agregado específico para garantizar que todas las operaciones dentro de un contexto estén alineadas y mantengan la consistencia del sistema.

![Step_9_Aggregates](assets/Event_Storming_Steps/9%20paso/paso_9_aggregates_1.png)
![Step_9_Aggregates](assets/Event_Storming_Steps/9%20paso/paso_9_aggregates_2.png)
![Step_9_Aggregates](assets/Event_Storming_Steps/9%20paso/paso_9_aggregates_3.png)


#### 4.1.1.1. Candidate Context Discovery

Nuestro equipo decidió usar la técnica **start-with-value** ya que empezamos a identificar la esencia del negocio lo cual es importante para tener una mejor proyección a futuro del negocio.

- **Identificación de Valores del Negocio:** <br>
  Analizamos los valores clave del negocio relacionados con la **gestión automatizada del riego** y el **análisis de datos del suelo,** **creación del cultivo**. Estas áreas son fundamentales para mejorar la eficiencia operativa en la gestión de recursos (como el agua) y para garantizar que los usuarios tengan acceso a información útil y precisa sobre el estado del suelo y los cultivos. <br>

- **Identificación de funcionalidades:**<br>
  A partir de los valores identificados, nos enfocamos en las funcionalidades más críticas, esto implica la **gestion de cuenta del usuario**, **creación del cultivo**, **notificaciones** que recibirán los usuarios cuando surja una alerta sobre su respectivo cultivo, el **sistema de reporte** las cuales se encargan de recopilar la información sobre el análisis del suelo cuando el **riego** esté en funcionamiento. <br>

- **Priorización de contextos:** <br>
  Priorizar los bounded contexts, nos permite identificar situaciones primordiales que se deben lograr de manera pronta. Además, priorizar los bounded contexts, ayuda a priorizar el core del negocio los cuales son esenciales para el desarrollo de la solución. <br>

Identificamos 5 Bounded Contexts:
  - Security
  - Crops
  - Notifications
  - Report
  - Watering

**Bounded Context Security:**

![Bounded Context Account](assets/Event_Storming_Steps/10%20paso/paso_10_bc_security.png)

**Bounded Context Crops:**

![Bounded Context Crops](assets/Event_Storming_Steps/10%20paso/paso_10_bc_crop.png)

**Bounded Context Notifications:**

![Bounded Context Notifications](assets/Event_Storming_Steps/10%20paso/paso_10_bc_notifications.png)

**Bounded Context Report:**

![Bounded Context Report](assets/Event_Storming_Steps/10%20paso/paso_10_bc_report.png)

**Bounded Context Watering:**

![Bounded Context Watering](assets/Event_Storming_Steps/10%20paso/paso_10_bc_watering.png)

**Visión General de los Bounded Contexts:**

![Visión General de los Bounded Contexts](assets/Event_Storming_Steps/10%20paso/paso_10_bc_overview.png)

#### 4.1.1.2. Domain Message Flows Modeling

En esta sección, se describe el proceso utilizado para visualizar la interacción entre los diferentes bounded contexts que conforman el sistema. El objetivo principal es entender cómo estos contextos colaboran para resolver los casos de uso del negocio y satisfacer las necesidades de los usuarios. Para lograr esto, se aplicó la técnica de Domain Storytelling, que facilita la representación gráfica de los flujos de mensajes entre actores, contextos y sistemas, permitiendo identificar claramente las responsabilidades y los puntos de comunicación entre cada componente del dominio.

**Scenario: Create Account**

En este escenario, se describe el proceso de creación de una cuenta de usuario en el sistema. El usuario interactúa con el contexto de `Security` para registrar sus credenciales y acceder a la plataforma.

![Create Account](assets/Domain%20Message%20Flows%20Modeling/messageFlow_createAccount_1.png)

**Scenario: Login**

En este escenario, se describe el proceso de inicio de sesión en el sistema. El usuario interactúa con el contexto de `Security` para autenticarse y acceder a las funcionalidades de la plataforma.

![Login](assets/Domain%20Message%20Flows%20Modeling/messageFlow_IniciaSesion.png)

**Scenario: Create Crop**

En este escenario, se describe el proceso de creación de un cultivo en el sistema. El usuario interactúa con el contexto de `Crops` para definir las características del cultivo y recibir recomendaciones sobre su cuidado.

![Create Crop](assets/Domain%20Message%20Flows%20Modeling/messageFlow_crearCultivo_2.png)

**Scenario: Progam Watering**

En este escenario, se describe el proceso de programación del riego automático o manual del cultivo. El usuario interactúa con el contexto de `Crop` y `Watering` para definir los horarios y la cantidad de agua necesaria para el cultivo.

![Program Watering](assets/Domain%20Message%20Flows%20Modeling/messageFlow_ProgramaRiego3.png)

**Scenario: Visualize Report**

En este escenario, se describe el proceso de visualización de los reportes de análisis del suelo y el estado del cultivo. El usuario interactúa con el contexto de `Report` para acceder a la información detallada sobre el rendimiento del cultivo y las recomendaciones para mejorar su crecimiento.

![Visualize Report](assets/Domain%20Message%20Flows%20Modeling/messageFlow_verReporte_4.png)

#### 4.1.1.3. Bounded Context Canvases

En esta sección, se detallan los pasos seguidos por el equipo para diseñar los bounded contexts identificados durante el proceso. El diseño de los bounded contexts fue iterativo, asegurando que cada contexto refleje de manera precisa los criterios de diseño y el conocimiento del dominio. Para cada bounded context, se siguieron los siguientes pasos clave:

- **Context Overview Definition:** Se definió el propósito y los límites de cada bounded context, alineándolos con el dominio del negocio.

- **Business Rules Distillation & Ubiquitous Language Capture:** Se identificaron las reglas de negocio clave y se capturó el lenguaje ubicuo para una comunicación clara entre el equipo.

- **Capability Analysis:** Se analizaron las capacidades que cada bounded context debe ofrecer.

- **Capability Layering:** Se aplicó la separación en capas de capacidades cuando fue necesario.

- **Dependencies Capture:** Se identificaron las dependencias con otros bounded contexts y sistemas externos.

- **Design Critique:** Se revisó el diseño para asegurar un desacoplamiento adecuado y alineación con los objetivos del negocio.

Con estos pasos, el equipo logró definir y diseñar los bounded contexts de manera efectiva, asegurando que cada uno cumpla con sus responsabilidades y contribuya al éxito del sistema en su conjunto.

**Bounded Context Canvases Security:**

![Bounded Context Canvas Security](assets/Bounded%20Context%20Canvases/bc_canvases_security_1.png)

**Bounded Context Canvases Crops:**

![Bounded Context Canvas Crops]()

**Bounded Context Canvases Notifications:**

![Bounded Context Canvas Notifications](assets/Bounded%20Context%20Canvases/bc_canvases_notifications_3.png)

**Bounded Context Canvases Watering:**

![Bounded Context Canvas Watering](assets/Bounded%20Context%20Canvases/bc_canvases_watering_2.png)

**Bounded Context Canvases Report:**

![Bounded Context Canvas Report]()

### 4.1.2 Context mapping

En esta sección, se analizan las relaciones entre los bounded contexts identificados y se asignan patrones de context mapping adecuados para cada uno:

##### Customer/Supplier

**Descripción:** En esta relación, un contexto actúa como Cliente (Customer) y otro como Proveedor (Supplier). El contexto Cliente necesita servicios o datos del contexto Proveedor. Esta relación establece una dependencia directa donde el proveedor suministra información o servicios que el cliente necesita para funcionar adecuadamente.

- "Crop" es Cliente de "Reading". En este caso, "Reading" proporciona datos en tiempo real o casi real a "Crop" para su procesamiento y análisis.
- "Crop" es Proveedor para "Reporting" y "Notifications". Aquí, "Crop" proporciona datos sobre el estado del cultivo, que son consumidos por "Reporting" para generar informes y por "Notifications" para enviar alertas y notificaciones.

##### Open/Host Service (OHS)
**Descripción:** En este patrón, un contexto expone un servicio bien definido que otros contextos pueden consumir sin tener que conocer o interactuar con la lógica interna de ese contexto. Este patrón es útil para integrar sistemas o contextos que necesitan acceder a servicios comunes, como autenticación, permisos o servicios externos.

- El contexto "Security" (Host) expone servicios de autenticación y autorización.

##### **Anticorruption Layer (ACL)**
**Descripción:** Este patrón se utiliza cuando un contexto necesita proteger su propio modelo de dominio de la influencia de otro contexto con el que interactúa. El contexto que usa un ACL implementa una capa de traducción que convierte las entradas o salidas del otro contexto a su propio modelo de dominio, evitando acoplarse directamente a los detalles internos del contexto con el que se comunica.

- El contexto "Notifications" utiliza un ACL para interactuar con "Crop". Esto asegura que cualquier cambio en el modelo de dominio de "Crop" no afecte directamente al modelo de "Notifications", manteniendo una separación clara entre los dos contextos.

<p align="center">
  <img src="assets/diagrams/context_mapping.png" alt="Context Mapping">

</p>

<p align="center">
  <a href="https://miro.com/welcomeonboard/c0RJcmExaEhJNHlsVkZJbktFaFFJaVhnV3d3dmdtNFFIa0R1eTh3d3NXVlVUSkRwVU5TaXZNNTZPbDF1M2RBcnwzNDU4NzY0NTUxMjMyMTk0MjkwfDI=?share_link_id=537960621738">Context Mapping Diagram</a>
</p>



### 4.1.3. Software Architecture

#### 4.1.3.1. Software Architecture System Landscape Diagram

Nuestra Startup cuenta con un sistema de software TheBigFun (aplicación web y móvil), adicionalmente se cuenta con un sistema que maneja dispositivos IoT.

<img src="./assets/C4/LandscapeDiagram.png" alt="hidrobots deploy diagram">

#### 4.1.3.2. Software Architecture Context Level Diagrams

Este diagrama de alto nivel permite definir las partes del sistema del software y su ambiente indicando todas las entidades que interactúan con dicho diagrama. Además, muestra la interacción de todas las entidades externas tales como una API o sistema IOT. Es por eso, que este diagrama se enfoca en los sucesos y restricciones que necesitaría el software.

<img src="./assets/C4/ContextDiagram.png" alt="hidrobots deploy diagram">

#### 4.1.3.3. Software Architecture Container Level Diagrams

Este diagrama sirve para incrementar el sistema del software mostrando los contenedores (aplicaciones, microservicios, base de datos, entre otros) de los cuales está compuesto el sistema del software. Además, se puede visualizar todas las relaciones de las entidades externas con las entidades propias del software.

<img src="./assets/C4/ConteinerDiagram.png" alt="hidrobots deploy diagram">


#### 4.1.3.4. Software Architecture Deployment Diagrams

Los Software Architecture Deployment Diagrams son representaciones visuales que muestran cómo los componentes de un sistema de software, como aplicaciones y bases de datos, se despliegan en diferentes entornos físicos o en la nube. Estos diagramas facilitan la comprensión de la infraestructura del sistema, las conexiones de red entre componentes, y cómo interactúan para soportar la funcionalidad del software.

 <img src="./assets/diagrams/hidrobots-deploy-diagram.png" alt="hidrobots deploy diagram">
   
## 4.2. Tactical-Level Domain-Driven Design



### 4.2.1. Bounded Context Security:

#### 4.2.1.1. Domain Layer
En la capa de dominio del contexto de seguridad para la aplicación de riego IoT, se encuentran los modelos de **Usuario** y **Permisos**. El **Usuario** representa a los diferentes usuarios que pueden acceder a la aplicación, y los **Permisos** definen los accesos y restricciones que tienen.

### Aggregate 1: Usuario

| **Nombre** | **Categoría** | **Propósito** |
|------------|---------------|---------------|
| Usuario    | Entity        | Representa a un usuario del sistema de riego IoT, contiene información sobre el acceso y roles del usuario |

**Atributos de Usuario**

| **Nombre**       | **Tipo de dato** | **Visibilidad** | **Descripción**                                      |
|------------------|------------------|-----------------|------------------------------------------------------|
| id               | UUID             | Private         | Identificador único del usuario                      |
| nombre           | String           | Private         | Nombre del usuario                                   |
| email            | String           | Private         | Correo electrónico del usuario                       |
| contraseña       | String           | Private         | Contraseña para acceso al sistema                    |
| fechaCreacion    | LocalDateTime    | Private         | Fecha de creación de la cuenta de usuario            |

**Métodos de Usuario**

| **Nombre**          | **Tipo de retorno** | **Visibilidad** | **Descripción**                                      |
|---------------------|---------------------|-----------------|------------------------------------------------------|
| Constructor         | Void                | Public          | Constructor de la entidad usuario                    |
| autenticarUsuario   | Boolean             | Public          | Autentica al usuario basándose en el email y contraseña |

### Aggregate 2: Permiso

| **Nombre** | **Categoría** | **Propósito** |
|------------|---------------|---------------|
| Permiso    | Entity        | Define los permisos que puede tener un usuario dentro del sistema de riego IoT |

**Atributos de Permiso**

| **Nombre**       | **Tipo de dato** | **Visibilidad** | **Descripción**                                      |
|------------------|------------------|-----------------|------------------------------------------------------|
| id               | UUID             | Private         | Identificador único del permiso                      |
| nombre           | String           | Private         | Nombre del permiso (e.g., "Ver Sensores", "Configurar Riego") |

**Métodos de Permiso**

| **Nombre**          | **Tipo de retorno** | **Visibilidad** | **Descripción**                                      |
|---------------------|---------------------|-----------------|------------------------------------------------------|
| Constructor         | Void                | Public          | Constructor de la entidad permiso                    |
| definirPermiso      | Void                | Public          | Establece los permisos que pueden ser asignados a un usuario |

### Aggregate 3: Sensor

| **Nombre** | **Categoría** | **Propósito** |
|------------|---------------|---------------|
| Sensor     | Entity        | Representa un sensor en el sistema de riego IoT que proporciona datos como humedad y temperatura |

**Atributos de Sensor**

| **Nombre**       | **Tipo de dato** | **Visibilidad** | **Descripción**                                      |
|------------------|------------------|-----------------|------------------------------------------------------|
| id               | UUID             | Private         | Identificador único del sensor                       |
| tipo             | String           | Private         | Tipo de sensor (e.g., Humedad, Temperatura)          |
| ubicacion        | String           | Private         | Ubicación física del sensor                          |
| valorActual      | Double           | Private         | Última lectura registrada por el sensor              |
| fechaUltimaLectura| LocalDateTime   | Private         | Fecha y hora de la última lectura del sensor         |

**Métodos de Sensor**

| **Nombre**          | **Tipo de retorno** | **Visibilidad** | **Descripción**                                      |
|---------------------|---------------------|-----------------|------------------------------------------------------|
| actualizarLectura   | Void                | Public          | Actualiza la última lectura registrada por el sensor  |
| obtenerLectura      | Double              | Public          | Retorna el valor actual del sensor                   |


#### 4.2.1.2. Interface Layer


En la capa de **Interface Layer** se modelan los controladores que se comunicarán con la interfaz de usuario para gestionar la seguridad y el manejo de sensores en el sistema de riego IoT.

### Controller 1: UserController

| **Name**             | **Category** | **Purpose**                                                |
|----------------------|--------------|------------------------------------------------------------|
| UserController       | Controller   | Controlador para los métodos CRUD relacionados con los usuarios. |

**Attributes of UserController**

| **Name**             | **Data Type**          | **Visibility** | **Description**                                                     |
|----------------------|------------------------|----------------|---------------------------------------------------------------------|
| userService          | UserService            | Private        | Servicio de usuarios para aplicar las reglas de negocio y lógica de autenticación. |
| userMapper           | UserMapper             | Private        | Mapper para transformar entidades de usuario en DTOs y viceversa.   |

**Methods of UserController**

| **Name**                   | **Return Type** | **Visibility** | **Description**                                                   |
|----------------------------|-----------------|----------------|-------------------------------------------------------------------|
| authenticateUser           | ResponseEntity  | Public         | Método para el inicio de sesión de un usuario utilizando credenciales y JWT. |
| registerUser               | ResponseEntity  | Public         | Método para el registro de un nuevo usuario en el sistema.        |
| getAllUsers                | ResponseEntity  | Public         | Método para retornar la lista de usuarios registrados.            |
| updateUser                 | ResponseEntity  | Public         | Método para actualizar la información de un usuario existente.    |
| deleteUser                 | ResponseEntity  | Public         | Método para eliminar un usuario del sistema por su ID.            |

### Controller 2: SensorController

| **Name**             | **Category** | **Purpose**                                                |
|----------------------|--------------|------------------------------------------------------------|
| SensorController     | Controller   | Controlador para los métodos CRUD relacionados con los sensores de riego. |

**Attributes of SensorController**

| **Name**             | **Data Type**          | **Visibility** | **Description**                                                     |
|----------------------|------------------------|----------------|---------------------------------------------------------------------|
| sensorService        | SensorService          | Private        | Servicio de sensores para aplicar las reglas de negocio relacionadas con la gestión de sensores. |

**Methods of SensorController**

| **Name**                   | **Return Type** | **Visibility** | **Description**                                                   |
|----------------------------|-----------------|----------------|-------------------------------------------------------------------|
| getAllSensors              | ResponseEntity  | Public         | Método para retornar la lista de todos los sensores registrados.  |
| addSensor                  | ResponseEntity  | Public         | Método para agregar un nuevo sensor al sistema de riego IoT.      |
| updateSensor               | ResponseEntity  | Public         | Método para actualizar los datos de un sensor específico.         |
| deleteSensor               | ResponseEntity  | Public         | Método para eliminar un sensor del sistema por su ID.             |

### Controller 3: PermissionController

| **Name**             | **Category** | **Purpose**                                                |
|----------------------|--------------|------------------------------------------------------------|
| PermissionController | Controller   | Controlador para la gestión de permisos de usuario en el sistema. |

**Attributes of PermissionController**

| **Name**             | **Data Type**          | **Visibility** | **Description**                                                     |
|----------------------|------------------------|----------------|---------------------------------------------------------------------|
| permissionService    | PermissionService      | Private        | Servicio de permisos para manejar las operaciones CRUD relacionadas. |

**Methods of PermissionController**

| **Name**                   | **Return Type** | **Visibility** | **Description**                                                   |
|----------------------------|-----------------|----------------|-------------------------------------------------------------------|
| getAllPermissions          | ResponseEntity  | Public         | Método para retornar la lista de todos los permisos en el sistema.|
| assignPermissionToUser     | ResponseEntity  | Public         | Método para asignar un permiso a un usuario.                      |
| removePermissionFromUser   | ResponseEntity  | Public         | Método para eliminar un permiso de un usuario.                    |





#### 4.2.1.3. Application Layer


En la capa de **Application Layer**, se han creado los servicios para cada entidad del contexto de seguridad del sistema de riego IoT. Esta capa gestiona la lógica empresarial y funcionalidad de la aplicación, brindando servicios como autenticación de usuarios, manejo de permisos, y gestión de sensores.

### Service 1: UserService

| **Name**             | **Category** | **Purpose**                                                |
|----------------------|--------------|------------------------------------------------------------|
| UserService          | Service      | Servicio con la lógica de negocio para la gestión de usuarios. |

**Attributes of UserService**

| **Name**             | **Data Type**          | **Visibility** | **Description**                                                     |
|----------------------|------------------------|----------------|---------------------------------------------------------------------|
| userRepository       | UserRepository         | Private        | Repositorio de usuarios para las operaciones CRUD.                  |
| passwordEncoder      | PasswordEncoder        | Private        | Utilizado para codificar las contraseñas de los usuarios.           |
| jwtHandler           | JwtHandler             | Private        | Manejador de JWT para la autenticación y autorización.              |

**Methods of UserService**

| **Name**                   | **Return Type** | **Visibility** | **Description**                                                   |
|----------------------------|-----------------|----------------|-------------------------------------------------------------------|
| authenticateUser           | ResponseEntity  | Public         | Autenticación de un usuario al iniciar sesión utilizando JWT.     |
| registerUser               | ResponseEntity  | Public         | Registrar un nuevo usuario en el sistema y codificar la contraseña.|
| getAllUsers                | List<User>      | Public         | Retornar lista de todos los usuarios registrados.                 |
| updateUser                 | User            | Public         | Actualizar la información de un usuario existente.                |
| deleteUser                 | ResponseEntity  | Public         | Eliminar un usuario del sistema por su ID.                        |
| loadUserByUsername         | UserDetails     | Public         | Cargar un usuario del sistema basado en su nombre de usuario.     |

### Service 2: PermissionService

| **Name**             | **Category** | **Purpose**                                                |
|----------------------|--------------|------------------------------------------------------------|
| PermissionService    | Service      | Servicio con la lógica de negocio para la gestión de permisos. |

**Attributes of PermissionService**

| **Name**             | **Data Type**          | **Visibility** | **Description**                                                     |
|----------------------|------------------------|----------------|---------------------------------------------------------------------|
| permissionRepository | PermissionRepository   | Private        | Repositorio de permisos para las operaciones CRUD.                  |

**Methods of PermissionService**

| **Name**                   | **Return Type** | **Visibility** | **Description**                                                   |
|----------------------------|-----------------|----------------|-------------------------------------------------------------------|
| getAllPermissions          | List<Permission> | Public         | Retorna la lista de todos los permisos del sistema.               |
| assignPermissionToUser     | ResponseEntity  | Public         | Asigna un permiso a un usuario específico.                        |
| removePermissionFromUser   | ResponseEntity  | Public         | Elimina un permiso asignado a un usuario.                         |

### Service 3: SensorService

| **Name**             | **Category** | **Purpose**                                                |
|----------------------|--------------|------------------------------------------------------------|
| SensorService        | Service      | Servicio con la lógica de negocio para la gestión de sensores. |

**Attributes of SensorService**

| **Name**             | **Data Type**          | **Visibility** | **Description**                                                     |
|----------------------|------------------------|----------------|---------------------------------------------------------------------|
| sensorRepository     | SensorRepository       | Private        | Repositorio de sensores para las operaciones CRUD.                  |

**Methods of SensorService**

| **Name**                   | **Return Type** | **Visibility** | **Description**                                                   |
|----------------------------|-----------------|----------------|-------------------------------------------------------------------|
| getAllSensors              | List<Sensor>    | Public         | Retorna la lista de todos los sensores registrados en el sistema. |
| updateSensorReading        | ResponseEntity  | Public         | Actualiza la última lectura de un sensor específico.              |
| addSensor                  | ResponseEntity  | Public         | Agrega un nuevo sensor al sistema de riego IoT.                   |
| deleteSensor               | ResponseEntity  | Public         | Elimina un sensor del sistema por su ID.                          |




#### 4.2.1.4. Infrastructure layer

En la capa de **Infrastructure Layer** de la aplicación de riego IoT para el contexto de seguridad, se encuentran los repositorios que gestionan la comunicación con la base de datos. Estos repositorios son responsables de la persistencia y consulta de entidades del dominio.

### Repository 1: UserRepository

| **Name**           | **Category** | **Purpose** |
|--------------------|--------------|-------------|
| UserRepository     | Repository   | Repositorio para la entidad User, gestiona la persistencia y recuperación de datos de usuarios en la base de datos. |

**Methods of UserRepository**

| **Name**            | **Return Type**   | **Visibility** | **Description**                                                              |
|---------------------|-------------------|----------------|------------------------------------------------------------------------------|
| findByUsername      | Optional<User>    | Public         | Encontrar usuario por su nombre de usuario.                                  |
| existsByUsername    | Boolean           | Public         | Verificar si existe un usuario según su nombre de usuario.                   |
| existsByEmail       | Boolean           | Public         | Verificar si existe un usuario según su correo electrónico.                  |
| save                | User              | Public         | Guardar un nuevo usuario o actualizar uno existente en la base de datos.     |
| deleteById          | Void              | Public         | Eliminar un usuario de la base de datos según su ID.                         |

### Repository 2: RoleRepository

| **Name**           | **Category** | **Purpose** |
|--------------------|--------------|-------------|
| RoleRepository     | Repository   | Repositorio para la entidad Role, gestiona la persistencia y consulta de roles en la base de datos. |

**Methods of RoleRepository**

| **Name**            | **Return Type**   | **Visibility** | **Description**                                                            |
|---------------------|-------------------|----------------|----------------------------------------------------------------------------|
| findByName          | Optional<Role>    | Public         | Retornar un rol según su nombre.                                           |
| existsByName        | Boolean           | Public         | Verificar si existe un rol según su nombre.                                |
| save                | Role              | Public         | Guardar un nuevo rol o actualizar uno existente en la base de datos.       |
| deleteById          | Void              | Public         | Eliminar un rol de la base de datos según su ID.                           |

### Repository 3: SensorRepository

| **Name**           | **Category** | **Purpose** |
|--------------------|--------------|-------------|
| SensorRepository   | Repository   | Repositorio para la entidad Sensor, maneja la persistencia y consulta de los datos de sensores. |

**Methods of SensorRepository**

| **Name**            | **Return Type**   | **Visibility** | **Description**                                                              |
|---------------------|-------------------|----------------|------------------------------------------------------------------------------|
| findById            | Optional<Sensor>  | Public         | Retornar un sensor específico por su ID.                                     |
| findByType          | List<Sensor>      | Public         | Buscar sensores según su tipo (humedad, temperatura, etc.).                  |
| save                | Sensor            | Public         | Guardar un nuevo sensor o actualizar uno existente en la base de datos.      |
| deleteById          | Void              | Public         | Eliminar un sensor de la base de datos según su ID.                          |

### Repository 4: PermissionRepository

| **Name**           | **Category** | **Purpose** |
|--------------------|--------------|-------------|
| PermissionRepository | Repository | Repositorio para la entidad Permission, gestiona la persistencia y consulta de permisos en la base de datos. |

**Methods of PermissionRepository**

| **Name**            | **Return Type**   | **Visibility** | **Description**                                                            |
|---------------------|-------------------|----------------|----------------------------------------------------------------------------|
| findByActionAndResource | Optional<Permission> | Public         | Retornar un permiso específico por su acción y recurso asociados.           |
| existsByActionAndResource | Boolean      | Public         | Verificar si existe un permiso según su acción y recurso.                   |
| save                | Permission        | Public         | Guardar un nuevo permiso o actualizar uno existente en la base de datos.    |
| deleteById          | Void              | Public         | Eliminar un permiso de la base de datos según su ID.                        |



#### 4.2.1.5. Bounded Context Software Architecture Component Level Diagrams
Esta sección incluye diagramas de componentes del nivel de arquitectura de software, mostrando cómo cada contenedor está compuesto por diferentes componentes, sus responsabilidades, y las interacciones entre ellos. Estos diagramas ayudan a entender la estructura interna de los contenedores y cómo se integran para formar el sistema completo.

<img src="./assets/diagrams/infraestructure-context-security.png" alt="hidrobots bounded-context-software-architecture-component-level-diagrams-security">

#### 4.2.1.6. Bounded Context Software Architecture Code Level Diagrams
Los diagramas de nivel de código en esta sección presentan detalles más finos sobre la implementación de los componentes dentro del bounded context. Incluyen diagramas de clases y bases de datos, proporcionando una vista más granular de la arquitectura y cómo los diferentes componentes trabajan juntos a nivel de código.



#### 4.2.1.6.1. Bounded Context Domain Layer Class Diagrams
Los diagramas de clases del Domain Layer detallan las relaciones entre clases, interfaces y objetos que componen la lógica de negocio. Incluyen detalles de atributos, métodos, visibilidad y relaciones, proporcionando una representación clara del diseño de clases en el Domain Layer.

*security*

<img src="./assets/diagrams/bounded-context-domain-layer-class-diagrams-security(1).png" alt="hidrobots bounded-context-domain-layer-class-diagrams-security.png">

#### 4.2.1.6.2. Bounded Context Database Design Diagram
El diagrama de diseño de bases de datos muestra cómo los objetos de base de datos están estructurados para la persistencia de datos. Incluye tablas, columnas, claves primarias y foráneas, y las relaciones entre tablas, proporcionando una representación clara del modelo de datos utilizado para respaldar el bounded context.

*security*

<img src="./assets/diagrams/bounded-context-database-design-diagram-security.png" alt="hidrobots bounded-context-database-design-diagram-security.png">


### 4.2.2. Bounded Context: Crop

El **Crop Context** se encarga de gestionar la información relacionada con los cultivos, incluyendo la creación, edición y eliminación de cultivos, así como la supervición de los sensores, dado que cada cultivo tiene asociado un conjunto de sensores IoT que monitorean su estado.













#### 4.2.2.1. Domain Layer

El **Domain Layer** del **Crop Context** encapsula la lógica de negocio y las reglas que rigen el funcionamiento de los cultivos.

**Aggregate 1**

| **Nombre**      | **Categoría**     | **Propósito** |
|:---------------|:-----------------|:--------------|
| Crop          | Entity/Aggregate  | Representa un cultivo con sus características y sensores asociados. |

**Atributos**

| **Nombre**        | **Tipo de dato**          | **Visibilidad** | **Descripción** |
|:-----------------:|:------------------------:|:---------------:|:----------------|
| id                | Long                     | Private         | Identificador único del cultivo |
| name              | String                   | Private         | Nombre del cultivo |
| type              | String                   | Private         | Tipo de cultivo (por ejemplo, maíz, trigo, tomate) |
| cropImage         | String                   | Private         | URL de la imagen del cultivo |


**Métodos**

| **Nombre**       | **Tipo de retorno** | **Visibilidad** | **Descripción** |
|:----------------:|:------------------:|:---------------:|:----------------|
| updateCropImage  | Void               | Public          | Actualiza la imagen del cultivo. |

**Aggregate 2**

| **Nombre**      | **Categoría**     | **Propósito** |
|:---------------|:-----------------|:--------------|
| Sensor        | Entity/Aggregate  | Representa un sensor IoT asociado a un cultivo. |

**Atributos**

| **Nombre**        | **Tipo de dato**          | **Visibilidad** | **Descripción** |
|:-----------------:|:------------------------:|:---------------:|:----------------|
| id                | Long                     | Private         | Identificador único del sensor |
| name              | String                   | Private         | Nombre del sensor |
| type              | String                   | Private         | Tipo de sensor (por ejemplo, humedad, temperatura, luz) |
| value             | Double                   | Private         | Valor actual del sensor |
| unit              | String                   | Private         | Unidad de medida del sensor |

**Métodos**

| **Nombre**       | **Tipo de retorno** | **Visibilidad** | **Descripción** |
|:----------------:|:------------------:|:---------------:|:----------------|
| CreateSensor     | Sensor              | Public          | Crea un nuevo sensor y lo asocia al cultivo. |
| updateSensorValue  | Void               | Public          | Actualiza el valor del sensor. |



#### 4.2.2.2. Interface Layer

La **Interface Layer** del **Crop Context** proporciona una API REST que permite a los usuarios gestionar los cultivos, incluyendo la creación, edición y eliminación de cultivos, así como la supervisión de los sensores asociados a cada cultivo.

**Componentes clave:**

- **Crop Controller**: Facilita la exposición de servicios a través de endpoints REST, permitiendo interacciones con el dominio de cultivos.

  **Endpoints**:
  - `GET /crops/{id}`: Recupera un cultivo específico basado en su ID.
  - `POST /crops`: Crea un nuevo cultivo con las características especificadas.
  - `PUT /crops/{id}`: Actualiza un cultivo existente con los nuevos datos proporcionados.
  - `DELETE /crops/{id}`: Elimina un cultivo específico.
  - `POST /crops/{cropId}/sensors/{sensorId}`: Añade un sensor al cultivo.
  - `DELETE /crops/{cropId}/sensors/{sensorId}`: Elimina un sensor del cultivo.

  **Atributos**:

  | **Nombre**        | **Tipo de retorno** | **Visibilidad** | **Descripción** |
  |:-----------------:|:------------------:|:---------------:|:----------------|
  | cropService       | CropService        | Private         | Servicio que gestiona la lógica de negocio de los cultivos. |

**Métodos del Controller**:

| **Nombre**       | **Tipo de retorno** | **Descripción** |
|:-----------------|:------------------:|:----------------|
| getCropById      | CropResource            | Recupera los detalles de un cultivo específico. |
| createCrop       | CropCreateResource            | Crea un nuevo cultivo y lo almacena. |
| updateCrop       | CropResource            | Actualiza un cultivo existente con los nuevos datos. |
| deleteCrop       | Void            | Elimina un cultivo específico. |
| addSensorToCrop  | Void            | Añade un sensor al cultivo. |
| removeSensorFromCrop | Void       | Elimina un sensor del cultivo. |

#### 4.2.2.3. Application Layer

La capa de Aplicación en el contexto de **Crop** gestiona la lógica empresarial y la funcionalidad de los cultivos.

**Service**

| **Nombre**          | **Categoría**     | **Propósito**                                  |
|:--------------------|:-----------------|:-----------------------------------------------|
| CropCommandService       | Service          | Provee métodos para los comandos relacionados con los cultivos como (POST, PUT, DELETE). |
| CropQueryService         | Service          | Provee métodos para las consultas relacionadas con los cultivos como (GET, GET/{id}). |
| SensorCommandService     | Service          | Provee métodos para los comandos relacionados con los sensores como (POST, DELETE). |
| SensorQueryService       | Service          | Provee métodos para las consultas relacionadas con los sensores como (GET, GET/{id}). |

**Atributos**

| **Nombre**           | **Tipo de retorno**          | **Visibilidad** | **Descripción**                                  |
|:---------------------|:-------------------------:|:---------------:|:-------------------------------------------------|
| cropRepository       | CropRepository           | Private         | Repositorio de cultivos.                         |
| sensorRepository     | SensorRepository         | Private         | Repositorio de sensores.                         |
| validator            | Validator                | Private         | Validador de atributos del cultivo.              |

**Métodos**

| **Nombre**           | **Tipo de retorno** | **Visibilidad** | **Descripción**                                  |
|:---------------------|:------------------:|:---------------:|:-------------------------------------------------|
| createCrop           | Crop                 | Public          | Crea un nuevo cultivo con las características especificadas. |
| updateCrop           | Crop                 | Public          | Actualiza un cultivo existente con los nuevos datos proporcionados. |
| deleteCrop           | Void                 | Public          | Elimina un cultivo específico. |
| getCropById          | Crop                 | Public          | Recupera un cultivo específico basado en su ID. |
| getAllCrops          | List<Crop>           | Public          | Recupera todos los cultivos existentes. |
| addSensorToCrop      | Void                 | Public          | Añade un nuevo sensor al cultivo. |
| removeSensorFromCrop | Void                 | Public          | Elimina un sensor del cultivo. |
| getSensorById        | Sensor               | Public          | Recupera un sensor específico basado en su ID. |

#### 4.2.2.4. Infrastructure Layer

La capa de Infraestructura en el contexto de **Crop** se encarga de la comunicación con la base de datos y otros servicios externos necesarios para el funcionamiento del sistema.

**Repository 1**

| **Nombre**          | **Categoría**     | **Propósito**                                  |
|:--------------------|:-----------------|:-----------------------------------------------|
| CropRepository      | Repository        | Provee métodos para acceder a los datos de los cultivos. |

**Métodos**

| **Nombre**           | **Tipo de retorno** | **Visibilidad** | **Descripción**                                  |
|:---------------------|:------------------:|:---------------:|:-------------------------------------------------|
| CreateCropCommand    | Crop                 | Public          | Crea un nuevo cultivo en la base de datos. |
| UpdateCropCommand    | Crop                 | Public          | Actualiza un cultivo existente en la base de datos. |
| DeleteCropCommand    | Void                 | Public          | Elimina un cultivo específico de la base de datos. |
| FindCropByIdQuery    | Crop                 | Public          | Recupera un cultivo específico de la base de datos basado en su ID. |
| FindAllCropsQuery    | List<Crop>           | Public          | Recupera todos los cultivos existentes de la base de datos. |

**Repository 2**

| **Nombre**          | **Categoría**     | **Propósito**                                  |
|:--------------------|:-----------------|:-----------------------------------------------|
| SensorRepository    | Repository        | Provee métodos para acceder a los datos de los sensores. |

**Métodos**

| **Nombre**           | **Tipo de retorno** | **Visibilidad** | **Descripción**                                  |
|:---------------------|:------------------:|:---------------:|:-------------------------------------------------|
| CreateSensorCommand  | Sensor               | Public          | Crea un nuevo sensor en la base de datos. |
| DeleteSensorCommand  | Void                 | Public          | Elimina un sensor específico de la base de datos. |
| FindSensorByIdQuery  | Sensor               | Public          | Recupera un sensor específico de la base de datos basado en su ID. |


#### 4.2.2.5. Bounded Context Software Architecture Component Level Diagrams

Esta sección incluye diagramas de componentes del nivel de arquitectura de software, mostrando cómo cada contenedor está compuesto por diferentes componentes, sus responsabilidades, y las interacciones entre ellos. Estos diagramas ayudan a entender la estructura interna de los contenedores y cómo se integran para formar el sistema completo.

![Bounded Context Software Architecture Component Level Diagrams Crop](assets/diagrams/Crop_Context.jpeg)


#### 4.2.2.6. Bounded Context Software Architecture Code Level Diagrams

En esta sección, el equipo presenta los diagramas que detallan la implementación de los componentes dentro de cada bounded context.

- **Domain Layer Class Diagrams:** Muestran las clases clave y relaciones en la capa de dominio.
- **Database Diagram:** Presenta la estructura de la base de datos, con tablas y relaciones.

Estos diagramas ofrecen una visión clara de cómo se implementan y gestionan los datos en cada contexto.

##### 4.2.4.2.1. Bounded Context Domain Layer Class Diagrams

Los diagramas de clases del Domain Layer detallan las relaciones entre clases, interfaces y objetos que componen la lógica de negocio. Incluyen detalles de atributos, métodos, visibilidad y relaciones, proporcionando una representación clara del diseño de clases en el Domain Layer.

**Crop Domain Layer Class Diagram**

El diagrama de clases del Domain Layer del **Crop Context** muestra las entidades y agregados clave, como `Crop` y `Sensor`, junto con sus atributos y métodos asociados.

![Crop Domain Layer Class Diagram](assets/diagrams/Crop_ClassDiagram.png)


##### 4.2.4.2.2. Bounded Context Database Design Diagram

El diagrama de diseño de bases de datos muestra cómo los objetos de base de datos están estructurados para la persistencia de datos. Incluye tablas, columnas, claves primarias y foráneas, y las relaciones entre tablas, proporcionando una representación clara del modelo de datos utilizado para respaldar el bounded context.

![Crop Database Design Diagram](assets/diagrams/Crop_DatabaseDiagram.png)

### 4.2.3. Bounded Context: Notifications

EL **Notification Context** tiene la responsabilidad de crear notificaciones de los diferentes eventos, como es el riego y análisis del suelo, y enviarlas a los respectivos usuarios.

#### 4.2.3.1. Domain Layer

En la presente capa del dominio, se encapsulan los diferentes modelos del negocio pertenecientes a la capa.

**Aggregate**

| **Nombre**     | **Categoría**    | **Propósito** |
|:---------------|:-----------------|:--------------|
| Notification   | Entity/Aggregate | Es una clase que abstrae la notificación que recibe un usuario. |

*Atributos*

| **Nombre**        | **Tipo de dato**          | **Visibilidad** | **Descripción** |
|:-----------------:|:------------------------:|:---------------:|:----------------|
| id                | Long                     | Private         | Identificador único de la notificación |
| notifiedAt        | DateTime                     | Private         | Fecha y hora de recepción de la notificación |
| description    | String        | Private         | Mensaje con una breve descripción de la notificación. |
| type | NotificationType        | Private         | Categoriza la notificación (Alert | Information) |
| user     | User | Private  | Usuario a quien va dirigido la notificación. |
| crop           | Crop                   | Private         | Cultivo del cual se generó la notificación |

*Métodos*

| **Nombre**       | **Tipo de retorno** | **Visibilidad** | **Descripción** |
|:----------------:|:------------------:|:---------------:|:----------------|
| calculateTimeFromNotification       | DateTime | Public          | Devuelve el tiempo que ha pasado desde recibir la notificación hasta ahora.  |
| isAlert  | Boolean             | Public          | Devuelve un valor bool en función de si es Alert o no. |
| isInformation | Boolean             | Public          | Devuelve un valor bool en función de si es Alert o no. |

**Value objects**

| **Nombre**     | **Categoría**    | **Propósito** |
|:---------------|:-----------------|:--------------|
| NotificationType   | Value object/Enum | Representa qué tipo es la notificación: ALERT o INFORMATION |

#### 4.2.3.2. Interface Layer

En la capa de interfaz, se crearon los controladores, que permiten la interacción entre la aplicación web y el sistema de notificaciones.

*Controller*

| **Nombre**     | **Categoría**    | **Propósito** |
|:---------------|:-----------------|:--------------|
| NotificationsController   | Controller | Controlador para notificaciones |

*Atributos*

| **Nombre**        | **Tipo de dato**          | **Visibilidad** | **Descripción** |
|:-----------------:|:------------------------:|:---------------:|:----------------|
| notificationCommandService | NotificationCommandService                  | Private         | Servicio de comandos para las notificaciones |
| notificationQueryService| NotificationQueryService                  | Private         | Servicio de queries para las notificaciones |

*Métodos*

| **Nombre**       | **Tipo de retorno** | **Visibilidad** | **Descripción** |
|:----------------:|:------------------:|:---------------:|:----------------|
| Constructor       | void | Public  | Constructor del controlador  |
| getNotificationsByUserId | List<ResponseEntity<Notification>> | Public  | Get notifications from a user |
| getNotificationById | ResponseEntity<Notification> | Public  | Get notification by id |
| postNotification | ResponseEntity<NotificationResponse> | Public  | Create notification |

#### 4.2.3.3. Application Layer

En esta capa, se definen las reglas del negocio, la lógica empresarial y la funcionalidad.

*Service 1*

| **Nombre**     | **Categoría**    | **Propósito** |
|:---------------|:-----------------|:--------------|
| NotificationCommandService | Service | Servicio de la lógica de los comandos |

*Atributos*

| **Nombre**        | **Tipo de dato**          | **Visibilidad** | **Descripción** |
|:-----------------:|:------------------------:|:---------------:|:----------------|
| notificationRepository | NotificationRepository                  | Private         | Repositorio de las notificaciones |
| cropRepository | CropRepository | Private         | Repositorio de los cultivos |
| userRepository | UserRepository | Private         | Repositorio de los user |

*Métodos*

| **Nombre**       | **Tipo de retorno** | **Visibilidad** | **Descripción** |
|:----------------:|:------------------:|:---------------:|:----------------|
| Constructor       | void | Public  | Constructor del servicio  |
| handle | NotificationResponse | Public  | Crea una notificación en función de un CreateNotificationCommand  |

*Service 2*

| **Nombre**     | **Categoría**    | **Propósito** |
|:---------------|:-----------------|:--------------|
| NotificationQueryService | Service | Servicio de la lógica de los queries |

*Atributos*

| **Nombre**        | **Tipo de dato**          | **Visibilidad** | **Descripción** |
|:-----------------:|:------------------------:|:---------------:|:----------------|
| notificationRepository | NotificationRepository                  | Private         | Repositorio de las notificaciones |
| userRepository | UserRepository | Private         | Repositorio de los user |

*Métodos*

| **Nombre**       | **Tipo de retorno** | **Visibilidad** | **Descripción** |
|:----------------:|:------------------:|:---------------:|:----------------|
| Constructor       | void | Public  | Constructor del servicio  |
| handle | List<NotificationResponse> | Public  | Lista las notificaciones en función de un user Id  |
| handle | NotificationResponse | Public  | Busca y retorna una notificación por su id  |


#### 4.2.3.4. Infrastructure Layer

En esta capa se define los repositorios del bounded context, que permitiráb el acceso a la base de datos.

*Repository*

| **Nombre**     | **Categoría**    | **Propósito** |
|:---------------|:-----------------|:--------------|
| NotificationRepository | Repository | Repositorio que almacena las notificaciones |

#### 4.2.3.5. Bounded Context Software Architecture Component Level Diagrams

<p align="center">
  <img src="assets/diagrams/notifications_context.jpg" alt="Context Mapping">
</p>

#### 4.2.3.6. Bounded Context Software Architecture Code Level Diagrams

#### 4.2.3.6.1. Bounded Context Domain Layer Class Diagrams.

<p align="center">
  <img src="assets/diagrams/notifications-database-model.png" alt="Notifications database model">
</p>

#### 4.2.3.6.2. Bounded Context Database Design Diagram. 

<p align="center">
  <img src="assets/diagrams/notifications-class-diagram.png" alt="Notifications class diagram">
</p>

### 4.2.5. Bounded Context: Reporting

El **Reporting Context** es responsable de recopilar y analizar los datos de los sensores IoT, como los niveles de humedad, minerales y temperatura, para generar reportes útiles para los agricultores e investigadores.

#### 4.2.5.1. Domain Layer

El **Domain Layer** encapsula la lógica de negocio y las reglas que rigen el funcionamiento del **Reporting Context**.

**Aggregate**

| **Nombre**      | **Categoría**     | **Propósito** |
|:---------------|:-----------------|:--------------|
| Report         | Entity/Aggregate  | Representa un análisis basado en los datos de los sensores, como niveles de humedad, temperatura y minerales del suelo. |

**Atributos**

| **Nombre**        | **Tipo de dato**          | **Visibilidad** | **Descripción** |
|:-----------------:|:------------------------:|:---------------:|:----------------|
| id                | Long                     | Private         | Identificador único del reporte |
| reportDate        | Date                     | Private         | Fecha de generación del reporte |
| humidityLevels    | Map<Date, Double>        | Private         | Niveles de humedad recopilados de los sensores IoT a lo largo del tiempo |
| temperatureLevels | Map<Date, Double>        | Private         | Niveles de temperatura recogidos de los sensores |
| mineralLevels     | Map<Date, Map<String, Double>> | Private  | Niveles de minerales (como nitrógeno, potasio, fósforo) por fecha y tipo |
| summary           | String                   | Private         | Resumen del estado del cultivo basado en los datos de humedad, temperatura y minerales |
| readingsList      | List<Reading>            | Private         | Lista de lecturas de sensores que incluyen datos como humedad, temperatura y minerales |

**Métodos**

| **Nombre**       | **Tipo de retorno** | **Visibilidad** | **Descripción** |
|:----------------:|:------------------:|:---------------:|:----------------|
| addReading       | Void               | Public          | Añadir una nueva lectura de sensores (humedad, temperatura, minerales) al reporte. |
| generateSummary  | String             | Public          | Genera un resumen basado en las lecturas de humedad, temperatura y minerales. |
| generateVisualization    | Object              | Public          | Genera un objeto que representa un gráfico de los datos del reporte. |

#### 4.2.5.2. Interface Context

La **Interface Layer** del **Reporting Context** proporciona una API REST que permite a los usuarios acceder y consultar los reportes generados a partir de los datos de los sensores.

**Componentes clave:**

- **Reporting Controller**: Facilita la exposición de servicios a través de endpoints REST, permitiendo interacciones con el dominio de reportes.

  **Endpoints**:
  - `GET /reports/{id}`: Recupera un reporte específico basado en su ID.
  - `POST /reports`: Crea un nuevo reporte utilizando las lecturas más recientes de los sensores.
  - `GET /reports/{id}/summary`: Devuelve un resumen del reporte solicitado.
  - `GET /reports/{id}/visualization`: Devuelve un objeto que representa una visualización gráfica de los datos del reporte.

**Métodos del Controller**:

| **Nombre**       | **Tipo de retorno** | **Descripción** |
|:-----------------|:------------------:|:----------------|
| getReportById    | ReportDTO          | Recupera los detalles de un reporte específico. |
| createReport     | ReportDTO          | Crea un nuevo reporte y lo almacena. |
| getReportSummary | String             | Devuelve un resumen textual del estado del cultivo. |
| getReportVisualization | Object        | Devuelve una visualización gráfica de los datos del reporte. |

#### 4.2.5.3. Application Context

La capa de Aplicación en el contexto de **Reporting** gestiona la lógica empresarial y la funcionalidad de generación de reportes.

**Service**

| **Nombre**          | **Categoría**     | **Propósito**                                  |
|:--------------------|:-----------------|:-----------------------------------------------|
| Reporting Services  | Service          | Provee métodos para los reportes. |

**Atributos**

| **Nombre**           | **Tipo de dato**          | **Visibilidad** | **Descripción**                                  |
|:---------------------|:-------------------------:|:---------------:|:-------------------------------------------------|
| mineralReportRepository | MineralReportRepository | Private         | Repositorio de reportes de minerales.            |
| humidityReportRepository | HumidityReportRepository | Private      | Repositorio de reportes de humedad.              |
| validator             | Validator                 | Private         | Validador de atributos del reporte.              |

**Métodos**

| **Nombre**           | **Tipo de retorno** | **Visibilidad** | **Descripción**                                  |
|:---------------------|:------------------:|:---------------:|:-------------------------------------------------|
| getAllReports        | Page/List          | Public          | Obtiene todos los reportes.                      |
| getReportById        | Report             | Public          | Obtiene un reporte según su ID.                  |
| createReport         | Report             | Public          | Crea un nuevo reporte.                           |
| updateReport         | Report             | Public          | Actualiza los datos de un reporte.               |
| deleteReport         | ResponseEntity     | Public          | Elimina un reporte.                              |
| addReadingToReport   | Report             | Public          | Agrega una lectura a un reporte existente.       |


#### 4.2.5.4. Infrastructure Context

En la capa de Infraestructura se gestiona la persistencia de datos para el contexto de **Reporting**.

**Repository**

| **Nombre**           | **Categoría**     | **Propósito**                              |
|:---------------------|:-----------------|:-------------------------------------------|
| Mineral Report Repository | Repository  | Repositorio que almacena la información de minerales. |
| Humidity Report Repository | Repository | Repositorio que almacena la información de humedad. |

**Métodos**

| **Nombre**           | **Tipo de retorno** | **Visibilidad** | **Descripción**                                 |
|:---------------------|:------------------:|:---------------:|:-----------------------------------------------|
| findById             | Report             | Public          | Devuelve un reporte según su ID.               |
| findByDateRange      | List<Report>       | Public          | Devuelve todos los reportes en un rango de fechas. |

#### 4.2.5.5. Bounded Context Software Architecture Component Level Diagrams

En esta sección, se presentan los diagramas a nivel de componentes que ilustran la arquitectura del **Reporting Context**. Estos diagramas muestran la estructura y las relaciones entre los componentes principales del sistema.

<p align="center">
  <img src="assets/diagrams/reporting_context.jpg" alt="Context Mapping">

</p>


#### 4.2.5.6. Bounded Context Software Architecture Code Level Diagrams


##### 4.2.5.6.1. Bounded Context Domain Layer Class Diagrams



##### 4.2.5.6.2. Bounded Context Database Design Diagram



</div>

# Capítulo V: Solutions UI/UX Design

## 5.1. Style Guidelines

### 5.1.1. General Style Guidelines

### 5.1.2. Web, Mobile and IoT Style Guidelines

## 5.2. Information Architecture

### 5.2.1. Organization Systems

### 5.2.2. Labeling Systems

### 5.2.3. SEO Tags and Meta Tags

### 5.2.4. Searching Systems

### 5.2.5. Navigation Systems

## 5.3. Landing Page UI Design

### 5.3.1. Landing Page Wireframe

### 5.3.2. Landing Page Mock-up

## 5.4. Application UX/UI Design

### 5.4.1. Applications Wireframes

### 5.4.2. Applications Wireflow Diagrams

### 5.4.3. Applications Mock-ups

### 5.4.4. Applications User Flow Diagrams

## 5.5. Applications Prototyping

# Capítulo VI: Product Implementation, Validation & Deployment

## 6.1. Software Configuration Management

### 6.1.1. Software Development Environment Configuration

### 6.1.2. Source Code Management

### 6.1.3. Source Code Style Guide & Conventions

### 6.1.4. Software Deployment Configuration

## 6.2. Landing Page, Services & Applications Implementation

### 6.2.X. Sprint n

#### 6.2.X.1. Sprint Planning n.

#### 6.2.X.2. Sprint Backlog n.

#### 6.2.X.3. Development Evidence for Sprint Review

#### 6.2.X.4. Testing Suite Evidence for Sprint Review.

#### 6.2.X.5. Execution Evidence for Sprint Review.

#### 6.2.X.6. Services Documentation Evidence for Sprint Review.

#### 6.2.X.7. Software Deployment Evidence for Sprint Review.

#### 6.2.X.8. Team Collaboration Insights during Sprint.

## 6.3. Validation Interviews.

### 6.3.1. Diseño de Entrevistas.

### 6.3.2. Registro de Entrevistas.

### 6.3.3. Evaluaciones según heurísticas.

## 6.4. Video About-the-Product.

# Conclusiones

## Conclusiones y recomendaciones

## Video About-the-Team

# Bibliografía

# Anexos
